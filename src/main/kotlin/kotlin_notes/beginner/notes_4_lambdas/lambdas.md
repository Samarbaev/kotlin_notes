
# Lambdas

### О чем заметка:
* лямбда-выражения и ссылки на члены класса
* работа с коллекциями в функциональном стиле
* последовательности: откладывание операций с коллекциями
* функциональные интерфейсы Java в Kotlin
* использование лямбда-выражений с получателями

#### 1. Лямбда-выражения 
* Лямбда выражения позволяют передавать фрагменты кода в функции
* Kotlin дает возможность передавать лямбда-выражения в функции за скобками и ссылаться на единственный аргумент лямбда-выражения как на it
* Код внутри лямбда выражения может читать и изменять локальные переменные функции, в которой оно вызывается



```kotlin
    // синтаксис лямбда выражения  
    // x: Int, y: Int - параметры
    // x + y - тело лямбда-выражения
    val sum = {x: Int, y: Int -> x + y}

    // как в Java вызывался слушатель
    button.setOnClickListener( new OnClickListener() {
        @Override
        public void onClick(View view) {
            /*action on click*/
        }
    }
        
    )

    // вызов этого же слушателя в Kotlin с помощью лямба выражения
    button.setOnClickListener {
        /* action on click */
    }
```

#### 2. Работа с коллекциями

Рассмотри такой пример, нам нужно реализовать функцию, которая ищет максимальный возраст в списке людей

```kotlin
    // обычная функция
    fun findTheOldest(people: List<Person>) {
        var maxAge = 0
        var theOldest: Person? = null
        
        for(person in people) {
            if(person.age > maxAge) {
                maxAge = person.age
                theOldest = person
            }
        }
        println(theOldest)
    }

    fun main() {
        // поиск самого взрослого человека через обычную функцию
        val people = listOf(Person("Alice", 29), Person("Bob", 31))
        findTheOldest(people)
        
        // для выразительности и элегантности kotlin предлагает большой набор стандартных фукнций
        // которые реализуют работа с лямбдами
        println(people.maxBy { it.age })
    }
```

#### 3. Оператор :: ссылки на функцию, конструктор или свойство

Если лямбда-выражение делегирует свою работу функции или свойству, его можно заменить ссылкой на метод, свойство или конструктор

```kotlin
    // пример выше мог бы выглядеть вот таким образом
    println(people.maxBy(Person::age))
```

#### 4. Некоторые стандартные функции для работы с коллекциями

Большинство операций над коллекциями могут выполняться без организации итераций вручную, с помощью функций
filter, map, all, any, flatMap, groupBy,

```kotlin
    // оператор map
    // преобразует исходную коллекцию в какой-то логике, которая передается в лямбде
    val list = listOf(1,2,3,4,5)
    println(list.map { it * it })
    // [1, 4, 9, 16, 25]

    // оператор filter
    // фильтрует исходную коллекцию оставляя в ней только те элементы, которые удовлетворяют условию предиката
    val people = listOf(Person("Alice", 29), Person("Bob", 31))
    println(people.filter { it.age > 30})
    // [Person(name = Bob, age = 31)]

    // оператор all
    // если мы хотим узнать соответствуют ли все элементы из коллекции какому-то предикату, то воспользуется оператором all
    val people = listOf(Person("Alice", 29), Person("Bob", 21))
    println(people.all { it.age <= 27})
    // false

    // оператор any 
    // если мы хотим узнать, что хотя бы один элемент из коллекции соответствует какому-то предикату, то воспользуемся any
    val people = listOf(Person("Alice", 29), Person("Bob", 21))
    println(people.any { it.age <= 27})
    // true

    // оператор groupBy
    // если нам надо объединить по какому-то признаку, то можно воспользоваться оператором groupBy
    val people = listOf(Person("Alice", 31),Person("Bob", 29),Person("Carol", 31) )
    println(people.groupBy { it.age })
    //{29 = [Person(name = "Bob",age = 29)], 31 = [Person(name = "Alice", age = 31),Person(name = "Carol", age = 31) ]}
    // выходной тип будет такой Map<Int, List<Person>>

    // оператор flatMap
    // функция flatMap работает следующим образом, она сначала преобразует каждый элемент в коллекцию
    // согласно функции, переданной в аргументе, а затем собирает несколько списков в один
    val listOfLists = listOf(
        listOf(1, 2, 3), 
        listOf(4, 5, 6), 
        listOf(7, 8, 9)
    )

    val flatMappedList = listOfLists.flatMap { it }

    println(flatMappedList) // [1, 2, 3, 4, 5, 6, 7, 8, 9]

    
```

#### 5. Последовательности

Последовательности - это ленивые коллекции, которые вычисляются в момент обращения. Хорошо подходит при работе, 
с большими объемами данных или с бесконечными последовательностями.

Важно отметить, что у последовательностей есть два типа операций:
1) Промежуточные операторы вычислений, например, `map`, `filter`
2) Терминальные операторы, например, `toList`, `forEach`, `sum`

```kotlin 
    // Этот код ничего не выведет в консоль, так как не был вызван терминальный оператор
    listOf(1,2,3,4).asSequence()
                   .map { print("map($it) "): it * it)}
                   .filter { print("filter($it) "): it % 2 == 0} 
                   
    
    // Этот код уже выполниться, так как есть терминальный оператор
     listOf(1,2,3,4).asSequence()
                    .map { print("map($it) "): it * it)}
                    .filter { print("filter($it) "): it % 2 == 0} 
                    .toList()
     // вывод
     // map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)
     
```
Важно заметить, что для последовательностей все операции применяются к каждому элементу поочередно:
сначала обрабатывается первый(преобразуется, затем фильтруется), затем второй и тд

